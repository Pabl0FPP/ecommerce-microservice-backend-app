name: Deploy Dev (AKS)

on:
  workflow_dispatch:
  push:
    branches: [ develop ]

env:
  K8S_NAMESPACE: ecommerce
  AZURE_RESOURCE_GROUP: rg-ecommerce-dev
  AKS_CLUSTER_NAME: aks-ecommerce-dev

jobs:
  deploy-core:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client

      - name: Get AKS credentials
        run: |
          az aks get-credentials --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AKS_CLUSTER_NAME }} --overwrite-existing
          kubectl cluster-info

      - name: Wait for cluster to be ready
        run: |
          kubectl wait --for=condition=ready nodes --all --timeout=300s || echo "Nodes may still be initializing"

      - name: Create namespace
        run: |
          kubectl apply -f k8s/namespace.yml || kubectl create namespace ${{ env.K8S_NAMESPACE }} || echo "Namespace already exists"

      - name: Apply core manifests
        run: |
          kubectl apply -n "${{ env.K8S_NAMESPACE }}" -f k8s/cloud-config-deployment.yml
          kubectl apply -n "${{ env.K8S_NAMESPACE }}" -f k8s/eureka-deployment.yml
          kubectl apply -n "${{ env.K8S_NAMESPACE }}" -f k8s/zipkin-deployment.yml

      - name: Wait core ready
        run: |
          kubectl rollout status -n "${{ env.K8S_NAMESPACE }}" deploy/cloud-config --timeout=10m || echo "Cloud Config may still be starting"
          kubectl rollout status -n "${{ env.K8S_NAMESPACE }}" deploy/service-discovery --timeout=10m || echo "Service Discovery may still be starting"

      - name: Show core services status
        run: |
          kubectl get pods -n "${{ env.K8S_NAMESPACE }}"
          kubectl get svc -n "${{ env.K8S_NAMESPACE }}" | grep -E "(NAME|cloud-config|service-discovery|zipkin)"

  deploy-services:
    runs-on: ubuntu-latest
    needs: deploy-core
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Get AKS credentials
        run: |
          az aks get-credentials --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AKS_CLUSTER_NAME }} --overwrite-existing
          kubectl cluster-info

      - name: Apply service manifests
        run: |
          kubectl apply -n "${{ env.K8S_NAMESPACE }}" -f k8s/api-gateway-deployment.yml
          kubectl apply -n "${{ env.K8S_NAMESPACE }}" -f k8s/user-deployment.yml
          kubectl apply -n "${{ env.K8S_NAMESPACE }}" -f k8s/product-deployment.yml
          kubectl apply -n "${{ env.K8S_NAMESPACE }}" -f k8s/order-deployment.yml
          kubectl apply -n "${{ env.K8S_NAMESPACE }}" -f k8s/payment-deployment.yml
          kubectl apply -n "${{ env.K8S_NAMESPACE }}" -f k8s/shipping-deployment.yml
          kubectl apply -n "${{ env.K8S_NAMESPACE }}" -f k8s/favourite-deployment.yml
          kubectl apply -n "${{ env.K8S_NAMESPACE }}" -f k8s/proxy-client-deployment.yml

      - name: Wait services ready
        shell: bash
        run: |
          set +e  # No fallar si alg√∫n servicio tarda m√°s
          for d in api-gateway user-service product-service order-service payment-service shipping-service favourite-service proxy-client; do
            echo "Waiting for $d rollout..."
            kubectl rollout status -n "${{ env.K8S_NAMESPACE }}" deploy/$d --timeout=10m || echo "‚ö†Ô∏è  $d may still be starting"
          done

      - name: Show all services status
        run: |
          echo "üìã Pods status:"
          kubectl get pods -n "${{ env.K8S_NAMESPACE }}"
          echo ""
          echo "üìã Services:"
          kubectl get svc -n "${{ env.K8S_NAMESPACE }}" -o wide
          echo ""
          echo "üí° Services are accessible via LoadBalancer or Ingress"

      - name: Show service endpoints
        run: |
          echo "üîç Service Endpoints:"
          kubectl get svc -n "${{ env.K8S_NAMESPACE }}" -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.spec.type}{"\t"}{.status.loadBalancer.ingress[0].ip}{"\n"}{end}' | while read name type ip; do
            if [ "$type" = "LoadBalancer" ] && [ -n "$ip" ]; then
              echo "  - $name: http://$ip"
            elif [ "$type" = "NodePort" ]; then
              nodeport=$(kubectl get svc "$name" -n "${{ env.K8S_NAMESPACE }}" -o jsonpath='{.spec.ports[0].nodePort}')
              echo "  - $name: NodePort $nodeport (configure external access)"
            else
              echo "  - $name: ClusterIP (internal only)"
            fi
          done
